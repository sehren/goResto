{"version":3,"file":"super-tabs-container.js","sourceRoot":"","sources":["../../src/components/super-tabs-container.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Component, Renderer2, ElementRef, Input, Output, EventEmitter, ViewChild, ViewEncapsulation,\n  AfterViewInit, OnDestroy, NgZone\n} from '@angular/core';\nimport { Platform } from 'ionic-angular';\nimport { SuperTabsPanGesture } from '../super-tabs-pan-gesture';\nimport { SuperTabsConfig } from './super-tabs';\n\n@Component({\n  selector: 'super-tabs-container',\n  template: '<div #container><ng-content></ng-content></div>',\n  encapsulation: ViewEncapsulation.None\n})\nexport class SuperTabsContainer implements AfterViewInit, OnDestroy {\n\n  /**\n   * Component configuration\n   * @type {SuperTabsConfig}\n   */\n  @Input()\n  config: SuperTabsConfig;\n\n  /**\n   * Number of tabs\n   * @type {number}\n   */\n  @Input()\n  tabsCount: number = 0;\n\n  /**\n   * Selected tab index\n   * @type {number}\n   */\n  @Input()\n  selectedTabIndex: number;\n\n  /**\n   * Notifies when a tab is selected\n   * @type {EventEmitter<Object>}\n   */\n  @Output()\n  tabSelect: EventEmitter<{ index: number; changed: boolean; }> = new EventEmitter<{ index: number; changed: boolean; }>();\n\n  /**\n   * Notifies when the container is being dragged\n   * @type {EventEmitter<TouchEvent>}\n   */\n  @Output()\n  onDrag: EventEmitter<TouchEvent> = new EventEmitter<TouchEvent>();\n\n  // View bindings\n\n  /**\n   * Container position\n   * @type {number}\n   */\n  containerPosition: number = 0;\n\n  // View children\n\n  /**\n   * The container wrapping all the tabs\n   */\n  @ViewChild('container')\n  container: ElementRef;\n\n  /**\n   * Single tab width\n   * @type {number}\n   */\n  tabWidth: number = 0;\n\n  /**\n   * Container width (sum of tab widths)\n   * @type {number}\n   */\n  containerWidth: number = 0;\n\n\n  // Animation stuff\n\n  /**\n   * Minimum position on x-axis that the container can be at\n   */\n  private minPosX: number;\n\n  /**\n   * Maximum position on x-axis that the container can be at\n   */\n  private maxPosX: number;\n\n  /**\n   * Pan gesture controller\n   */\n  private gesture: SuperTabsPanGesture;\n\n  /**\n   * Boolean indicating whether swiping is globally enabled\n   * @type {boolean}\n   */\n  private globalSwipeEnabled: boolean = true;\n\n  /**\n   * Set of booleans to indicate whether swiping is enabled on each tab\n   * @type {{}}\n   */\n  private swipeEnabledPerTab: {[index: number]: boolean} = {};\n\n  constructor(\n    private el: ElementRef,\n    private rnd: Renderer2,\n    private plt: Platform,\n    private ngZone: NgZone\n  ) {}\n\n  ngAfterViewInit() {\n    this.init();\n  }\n\n  ngOnDestroy() {\n    this.gesture && this.gesture.destroy();\n  }\n\n  /**\n   * Enable or disable swiping globally\n   * @param enable {boolean} set to true to enable\n   */\n  enableTabsSwipe(enable: boolean) {\n    this.globalSwipeEnabled = enable;\n  }\n\n  /**\n   * Enable or disable swiping when a tab is selected\n   * @param tabIndex {number} tab index\n   * @param enable {boolean} set to true to enable\n   */\n  enableTabSwipe(tabIndex: number, enable: boolean) {\n    this.swipeEnabledPerTab[tabIndex] = enable;\n  }\n\n  refreshDimensions() {\n    this.calculateContainerWidth();\n    this.setContainerWidth();\n    this.refreshMinMax();\n  }\n\n  getNativeElement(): HTMLElement {\n    return this.el.nativeElement;\n  }\n\n  private init() {\n\n    this.refreshDimensions();\n\n    this.gesture = new SuperTabsPanGesture(this.plt, this.container.nativeElement, this.config, this.rnd);\n\n    this.gesture.onMove = (delta: number) => {\n      if (this.globalSwipeEnabled === false) return;\n      if (this.swipeEnabledPerTab[this.selectedTabIndex] === false) return;\n      if ((this.containerPosition === this.maxPosX && delta >= 0) || (this.containerPosition === this.minPosX && delta <= 0)) return;\n      this.containerPosition += delta;\n      this.plt.raf(() => {\n        this.onDrag.emit();\n        this.moveContainer();\n      })\n    };\n\n    this.gesture.onEnd = (shortSwipe: boolean, shortSwipeDelta?: number) => {\n      if (this.globalSwipeEnabled === false) return;\n      if (this.swipeEnabledPerTab[this.selectedTabIndex] === false) return;\n\n      // get tab index based on container position\n      let tabIndex = Math.round(this.containerPosition / this.tabWidth);\n\n      // handle short swipes\n      // only short swipe if we didn't change tab already in this gesture\n      (tabIndex === this.selectedTabIndex) && shortSwipe && ((shortSwipeDelta < 0 && tabIndex++) || (shortSwipeDelta > 0 && tabIndex--));\n\n      // get location based on tab index\n      const position = Math.max(this.minPosX, Math.min(this.maxPosX, tabIndex * this.tabWidth));\n\n      tabIndex = position / this.tabWidth;\n\n      // move container if we changed position\n      if (position !== this.containerPosition) {\n        this.plt.raf(() =>\n          this.moveContainer(true, position)\n            .then(() =>\n              this.ngZone.run(() => this.setSelectedTab(tabIndex))\n            )\n        );\n      } else this.setSelectedTab(tabIndex);\n\n    };\n  }\n\n  /**\n   * Set the selected tab.\n   * Emits a tabSelect event with the tab index, and a boolean indicating whether the tab changed or not.\n   * @param index {number} tab index\n   */\n  private setSelectedTab(index: number) {\n    this.tabSelect.emit({ index, changed: index !== this.selectedTabIndex });\n    this.selectedTabIndex = index;\n  }\n\n  /**\n   * Calculate the container's width.\n   * It's usually the number of tabs x tab width.\n   */\n  private calculateContainerWidth() {\n    this.containerWidth = this.tabWidth * this.tabsCount;\n  }\n\n  /**\n   * Set the container's width via CSS property\n   */\n  private setContainerWidth() {\n    this.rnd.setStyle(this.container.nativeElement, 'width', this.containerWidth + 'px');\n  }\n\n  /**\n   * Slide to a specific tab\n   * @param index {number} tab index\n   * @param [animate=true] {boolean} set to true to animate\n   */\n  slideTo(index: number, animate: boolean = true): void {\n    this.plt.raf(() => this.moveContainer(animate, index * this.tabWidth));\n  }\n\n  /**\n   * Moves the container to a specified position\n   * @param [animate=false] {boolean} set to true to animate\n   * @param [positionX] {number} position on x-axis\n   */\n  private async moveContainer(animate: boolean = false, positionX?: number) {\n    const el: HTMLElement = this.container.nativeElement;\n\n    if (animate) {\n\n      if (el.style[this.plt.Css.transform].indexOf('all') === -1) {\n        this.rnd.setStyle(el, this.plt.Css.transition, `all ${this.config.transitionDuration}ms ${this.config.transitionEase}`);\n      }\n\n      this.rnd.setStyle(el, this.plt.Css.transform, `translate3d(${-1 * positionX}px, 0, 0)`);\n\n      this.containerPosition = positionX;\n\n    } else {\n\n      if (positionX) {\n        this.containerPosition = positionX;\n      }\n\n      if (el.style[this.plt.Css.transform] !== 'initial') {\n        this.rnd.setStyle(el, this.plt.Css.transition, 'initial');\n      }\n\n      this.containerPosition = Math.max(this.minPosX, Math.min(this.maxPosX, this.containerPosition));\n\n      this.rnd.setStyle(el, this.plt.Css.transform, `translate3d(${-1 * this.containerPosition}px, 0, 0)`);\n\n    }\n  }\n\n  /**\n   * Refresh the min and max positions that the container can be at.\n   * The minimum position is always 0, the maximum position is the number of tabs x tab width.\n   */\n  private refreshMinMax(): void {\n    this.minPosX = 0;\n    this.maxPosX = (this.tabsCount - 1) * this.tabWidth;\n  }\n\n}\n"]}